From 1aee2ab2bfca5c0c130fb1d2522b237f66304c27 Mon Sep 17 00:00:00 2001
From: Elliot Buller <elliot@tinylabs.io>
Date: Thu, 25 Jun 2020 12:10:43 -0600
Subject: [PATCH] TL patches - gen, overlap, verilator

---
 rtl/verilog/ahb3lite_interconnect.sv          |  22 +-
 .../ahb3lite_interconnect_master_port.sv      |  44 ++-
 .../ahb3lite_interconnect_slave_port.sv       |  30 +-
 .../ahb3lite_interconnect_slave_priority.sv   |   6 +-
 sw/ahb3lite_intercon.py                       | 319 ++++++++++++++++++
 sw/verilogwriter.py                           | 130 +++++++
 6 files changed, 507 insertions(+), 44 deletions(-)
 create mode 100644 sw/ahb3lite_intercon.py
 create mode 100644 sw/verilogwriter.py

diff --git a/rtl/verilog/ahb3lite_interconnect.sv b/rtl/verilog/ahb3lite_interconnect.sv
index 3072eef..4c4cc39 100644
--- a/rtl/verilog/ahb3lite_interconnect.sv
+++ b/rtl/verilog/ahb3lite_interconnect.sv
@@ -51,17 +51,17 @@
 //  SLAVE_MASK                 Per Master Slave mask
 //  ERROR_ON_SLAVE_MASK        Per Master error response on masked slave
 // ------------------------------------------------------------------
-// REUSE ISSUES 
+// REUSE ISSUES
 //   Reset Strategy      : external asynchronous active low; HRESETn
 //   Clock Domains       : HCLK, rising edge
-//   Critical Timing     : 
+//   Critical Timing     :
 //   Test Features       : na
 //   Asynchronous I/F    : no
 //   Scan Methodology    : na
 //   Instantiations      : ahb3lite_interconnect_master_port
 //                         ahb3lite_interconnect_slave_port
 //   Synthesizable (y/n) : Yes
-//   Other               :                                         
+//   Other               :
 // -FHDR-------------------------------------------------------------
 
 /*
@@ -70,7 +70,7 @@
  *   sets the number of AHB slave-ports on the switch
  *   AHB bus masters connect to these ports. There should only be 1 bus master per slave port
  *
- *   HSEL is used to determine if the port is accessed. This allows a single AHB bus master to be connected to multiple switches. 
+ *   HSEL is used to determine if the port is accessed. This allows a single AHB bus master to be connected to multiple switches.
  *   It is allowed to drive HSEL with a static/hardwired signal ('1'). This results in a smaller (less logic resources) and faster (larger slack) switch.
  *
  *   'priority' sets the priority of the port. This is used to determine what slave-port (AHB bus master) gets granted access to a master-port when multiple slave-ports want to access the same master-port. The slave-port with the highest priority is granted access.
@@ -94,7 +94,7 @@
  *   Setting a MASK bit to '0' indicates that master will never access the slave.
  *   Setting a MASK bit to '1' indicates that master will/can access the slave.
  *
- *   example: MASTERS=3, SLAVES=2. 
+ *   example: MASTERS=3, SLAVES=2.
  *          | 2 1 0
  *          |------
  *         1| 1 1 0    Slave[1] can only be accessed by masters 2 and 1. Master[0] never accesses Slave[1]
@@ -124,7 +124,7 @@ module ahb3lite_interconnect #(
   parameter                  SLAVES                       = 8, //number of AHB slaves
 
   parameter bit [SLAVES-1:0] SLAVE_MASK         [MASTERS] = '{MASTERS{ {SLAVES{1'b1}} }},
-  parameter bit [SLAVES-1:0] ERROR_ON_SLAVE_MASK[MASTERS] = invert_slave_mask(),
+  parameter bit [SLAVES-1:0] ERROR_ON_SLAVE_MASK[MASTERS] = '{MASTERS{ {SLAVES{1'b0}} }}, //invert_slave_mask(),
 
   //actually localparam
   parameter                  MASTER_BITS          = $clog2(MASTERS+1)
@@ -236,7 +236,7 @@ module ahb3lite_interconnect #(
   //
   // Module Body
   //
-  
+
   /*
    * Hookup Master Interfaces
    */
@@ -253,7 +253,7 @@ generate
   master_port (
     .HRESETn             ( HRESETn                ),
     .HCLK                ( HCLK                   ),
-	 
+
     //AHB Slave Interfaces (receive data from AHB Masters)
     //AHB Masters conect to these ports
     .mst_priority        ( mst_priority       [m] ),
@@ -270,7 +270,7 @@ generate
     .mst_HREADYOUT       ( mst_HREADYOUT      [m] ),
     .mst_HREADY          ( mst_HREADY         [m] ),
     .mst_HRESP           ( mst_HRESP          [m] ),
-    
+
     //AHB Master Interfaces (send data to AHB slaves)
     //AHB Slaves connect to these ports
     .slvHADDRmask        ( slv_addr_mask          ),
@@ -331,7 +331,7 @@ endgenerate
     begin: master
       for (s=0; s<SLAVES; s++)
       begin: slave
-          assign tomstgrant [m][s] = fromslvgrant    [s][m];   
+          assign tomstgrant [m][s] = fromslvgrant    [s][m];
           assign tomstHRDATA[m][s] = fromslvHRDATA   [s];
           assign tomstHREADY[m][s] = fromslvHREADYOUT[s];
           assign tomstHRESP [m][s] = fromslvHRESP    [s];
@@ -353,7 +353,7 @@ generate
   slave_port (
     .HRESETn         ( HRESETn              ),
     .HCLK            ( HCLK                 ),
-	 
+
     //AHB Slave Interfaces (receive data from AHB Masters)
     //AHB Masters connect to these ports
     .mstpriority     ( toslvpriority    [s] ),
diff --git a/rtl/verilog/ahb3lite_interconnect_master_port.sv b/rtl/verilog/ahb3lite_interconnect_master_port.sv
index de9d6ab..11de1b0 100644
--- a/rtl/verilog/ahb3lite_interconnect_master_port.sv
+++ b/rtl/verilog/ahb3lite_interconnect_master_port.sv
@@ -51,18 +51,18 @@
 //                                          1:slave can be addressed
 //  ERROR_ON_SLAVE_MASK 1+       ERROR when addressing masked slave
 // ------------------------------------------------------------------
-// REUSE ISSUES 
+// REUSE ISSUES
 //   Reset Strategy      : external asynchronous active low; HRESETn
 //   Clock Domains       : HCLK, rising edge
-//   Critical Timing     : 
+//   Critical Timing     :
 //   Test Features       : na
 //   Asynchronous I/F    : no
 //   Scan Methodology    : na
 //   Instantiations      : none
 //   Synthesizable (y/n) : Yes
-//   Other               :                                         
+//   Other               :
 // -FHDR-------------------------------------------------------------
- 
+
 module ahb3lite_interconnect_master_port #(
   parameter              HADDR_SIZE          = 32,
   parameter              HDATA_SIZE          = 32,
@@ -82,7 +82,7 @@ module ahb3lite_interconnect_master_port #(
   //AHB Slave Interfaces (receive data from AHB Masters)
   //AHB Masters connect to these ports
   input  [MASTER_BITS-1:0]              mst_priority,
- 
+
   input                                 mst_HSEL,
   input  [HADDR_SIZE -1:0]              mst_HADDR,
   input  [HDATA_SIZE -1:0]              mst_HWDATA,
@@ -141,6 +141,8 @@ module ahb3lite_interconnect_master_port #(
 
   logic [SLAVES     -1:0] current_HSEL,      //current-cycle addressed slave
                           pending_HSEL,      //pending-cycle addressed slave
+                          current_HSELx,
+                          pending_HSELx,
                           error_masked_HSEL; //generate error when accessing masked slave
 
   logic                   local_HREADYOUT,
@@ -190,7 +192,7 @@ module ahb3lite_interconnect_master_port #(
   /*
    * Register Address Phase Signals
    */
-  always @(posedge HCLK,negedge HRESETn)
+  always @(posedge HCLK)
     if      (!HRESETn    ) regHTRANS <= HTRANS_IDLE;
     else if ( mst_HREADY ) regHTRANS <= mst_HSEL ? mst_HTRANS : HTRANS_IDLE;
 
@@ -205,7 +207,7 @@ module ahb3lite_interconnect_master_port #(
         regHBURST    <= mst_HBURST;
         regHPROT     <= mst_HPROT;
         regHMASTLOCK <= mst_HMASTLOCK;
-    end 
+    end
 
   /*
    * Generate local HREADY and HRESP
@@ -214,13 +216,13 @@ module ahb3lite_interconnect_master_port #(
    * Always generate HREADY when IDLE, otherwise insert wait state
    * HRESP is always OKAY, except when addressing masked slave
    */
-  always @(posedge HCLK,negedge HRESETn)
+  always @(posedge HCLK)
     if      (!HRESETn    ) local_HREADYOUT <= 1'b1;
     else if ( local_HRESP) local_HREADYOUT <= 1'b1; //HRESP='1' 2nd cycle of ERROR-response
     else if ( mst_HREADY ) local_HREADYOUT <= (mst_HTRANS == HTRANS_IDLE) | ~mst_HSEL;
 
 
-  always @(posedge HCLK,negedge HRESETn)
+  always @(posedge HCLK)
     if      (!HRESETn   ) local_HRESP <= HRESP_OKAY;
     else if ( mst_HREADY) local_HRESP <= |error_masked_HSEL ? HRESP_ERROR : HRESP_OKAY;
 
@@ -240,9 +242,9 @@ module ahb3lite_interconnect_master_port #(
    *                 else go to NO_ACCESS
    */
 
-  always @(posedge HCLK,negedge HRESETn)
+  always @(posedge HCLK)
     if (!HRESETn) access_state <= NO_ACCESS;
-    else 
+    else
       case (access_state)
         NO_ACCESS     : if      (~|current_HSEL && ~|pending_HSEL  ) access_state <= NO_ACCESS;
                         else if ( |(current_HSEL & master_granted) ) access_state <= ACCESS_GRANTED;
@@ -290,7 +292,7 @@ module ahb3lite_interconnect_master_port #(
   assign can_switch = ( no_access      & ~|(current_HSEL & master_granted) ) |
                       ( access_pending & ~|(pending_HSEL & master_granted) ) |
                       ( access_granted & ( ~mst_HSEL |
-                                           (mst_HSEL & ~mst_HMASTLOCK & mst_HREADY & 
+                                           (mst_HSEL & ~mst_HMASTLOCK & mst_HREADY &
                                              ( (mst_HTRANS == HTRANS_IDLE                                              ) |
                                                (mst_HTRANS == HTRANS_NONSEQ & mst_HBURST == HBURST_SINGLE              ) |
                                                (mst_HTRANS == HTRANS_SEQ    & mst_HBURST != HBURST_INCR   & ~|burst_cnt) )
@@ -308,9 +310,9 @@ module ahb3lite_interconnect_master_port #(
 generate
   for (s=0; s<SLAVES; s++)
   begin: gen_HSEL
-      assign current_HSEL     [s] = SLAVE_MASK[s] & (mst_HTRANS != HTRANS_IDLE) &
+      assign current_HSELx    [s] = SLAVE_MASK[s] & (mst_HTRANS != HTRANS_IDLE) &
                                       ( (mst_HADDR & slvHADDRmask[s]) == (slvHADDRbase[s] & slvHADDRmask[s]) );
-      assign pending_HSEL     [s] = SLAVE_MASK[s] & (regHTRANS  != HTRANS_IDLE) &
+      assign pending_HSELx    [s] = SLAVE_MASK[s] & (regHTRANS  != HTRANS_IDLE) &
                                       ( (regHADDR  & slvHADDRmask[s]) == (slvHADDRbase[s] & slvHADDRmask[s]) );
       assign slvHSEL          [s] = access_pending ? (pending_HSEL[s]) : (mst_HSEL & current_HSEL[s]);
 
@@ -320,12 +322,22 @@ generate
   end
 endgenerate
 
+  /*
+   * Ensure only one slave bit set per master. Lowest set bit will have precedence.
+   * This will prioritize lower indexed slaves and prevent overlapping memory maps
+   * from causing issues.
+   */
+  assign current_HSEL = -current_HSELx & current_HSELx;
+  assign pending_HSEL = -pending_HSELx & pending_HSELx;
+
   /*
    * Check if granted access
    */
-  always @(posedge HCLK,negedge HRESETn)
+  always @(posedge HCLK)
     if      (!HRESETn     ) slave_sel <= 'h0;
+    /* verilator lint_off WIDTH */
     else if ( mst_HREADY  ) slave_sel <= onehot2int( slvHSEL );
+    /* verilator lint_on WIDTH */
 
   /*
    * Outgoing data (to slaves)
@@ -349,7 +361,7 @@ endgenerate
    */
   assign mst_HRDATA    =                  slvHRDATA[slave_sel];
   assign mst_HREADYOUT = access_granted ? slvHREADY[slave_sel] : local_HREADYOUT; //master's HREADYOUT is driven by slave's HREADY (slv_HREADY -> mst_HREADYOUT)
-  assign mst_HRESP     = access_granted ? slvHRESP [slave_sel] : local_HRESP; 
+  assign mst_HRESP     = access_granted ? slvHRESP [slave_sel] : local_HRESP;
 endmodule
 
 
diff --git a/rtl/verilog/ahb3lite_interconnect_slave_port.sv b/rtl/verilog/ahb3lite_interconnect_slave_port.sv
index 3400e6f..8b38dc8 100644
--- a/rtl/verilog/ahb3lite_interconnect_slave_port.sv
+++ b/rtl/verilog/ahb3lite_interconnect_slave_port.sv
@@ -1,3 +1,4 @@
+/* verilator lint_off WIDTH */
 /////////////////////////////////////////////////////////////////////
 //   ,------.                    ,--.                ,--.          //
 //   |  .--. ' ,---.  ,--,--.    |  |    ,---. ,---. `--' ,---.    //
@@ -48,16 +49,16 @@
 //  HDATA_SIZE        1+       Data bus size            32      bits
 //  MASTERS           1+       Number of Master ports   3       ports
 // ------------------------------------------------------------------
-// REUSE ISSUES 
+// REUSE ISSUES
 //   Reset Strategy      : external asynchronous active low; HRESETn
 //   Clock Domains       : HCLK, rising edge
-//   Critical Timing     : 
+//   Critical Timing     :
 //   Test Features       : na
 //   Asynchronous I/F    : no
 //   Scan Methodology    : na
 //   Instantiations      : none
 //   Synthesizable (y/n) : Yes
-//   Other               :                                         
+//   Other               :
 // -FHDR-------------------------------------------------------------
 
 
@@ -127,15 +128,15 @@ module ahb3lite_interconnect_slave_port #(
                                            last_granted_master_idx; //last granted master for requested priority level
   logic [MASTERS    -1:0][MASTER_BITS-1:0] last_granted_masters;    //per priority level, for round-robin
 
-  
+
   logic [MASTER_BITS-1:0]                  granted_master_idx,      //granted master as index
                                            granted_master_idx_dly;  //deleayed granted master index (for HWDATA)
-  
+
   logic                                    can_switch_master;       //Slave may switch to a new master
 
-  
+
   genvar m;
-  
+
 
   //////////////////////////////////////////////////////////////////
   //
@@ -161,6 +162,7 @@ module ahb3lite_interconnect_slave_port #(
    * Intel Quartus does not support recursive functions.
    * Even though this one would be perfectly fine
   */
+`ifdef RECURSIVE_FUNCTIONS_SUPPORTED
   function automatic [MASTER_BITS-1:0] highest_requested_priority (
     input [MASTERS-1:0]                  hsel,
     input [MASTERS-1:0][MASTER_BITS-1:0] priorities,
@@ -185,7 +187,7 @@ module ahb3lite_interconnect_slave_port #(
     //finally compare lo and hi priorities
     return (priority_hi > priority_lo) ? priority_hi : priority_lo;
   endfunction : highest_requested_priority
-
+`endif
 
   //If every master has its own unique priority, this just becomes HSEL
   function [MASTERS-1:0] requesters;
@@ -210,7 +212,7 @@ module ahb3lite_interconnect_slave_port #(
 
     //default value, don't switch if not needed
     nxt_master = current_master;
-	 
+
     //implement round-robin
     offset = last_master +1;
     sr = {pending_masters,pending_masters};
@@ -238,7 +240,7 @@ module ahb3lite_interconnect_slave_port #(
 
     //default value, don't switch if not needed
     nxt_master = current_master;
-	 
+
     //implement round-robin
     mst_lst     = {pending_masters,pending_masters} >> last_master;
     mst_idx_lst = mst_idx_lst >> (last_master * MASTER_BITS);
@@ -294,14 +296,14 @@ module ahb3lite_interconnect_slave_port #(
 
 
   //select new master
-  always @(posedge HCLK, negedge HRESETn)
+  always @(posedge HCLK)
     if      (!HRESETn       ) granted_master <= 'h1;
     else if ( slv_HREADY    )
       if (can_switch_master) granted_master <= (1 << pending_master_idx);
 
 
   //store current master (for this priority level)
-  always @(posedge HCLK, negedge HRESETn)
+  always @(posedge HCLK)
     if      (!HRESETn       ) last_granted_masters <= 'h1;
     else if ( slv_HREADY)
       if (can_switch_master) last_granted_masters[requested_priority_lvl] <= pending_master_idx;
@@ -310,7 +312,7 @@ module ahb3lite_interconnect_slave_port #(
   /*
    * Get signals from current requester
    */
-  always @(posedge HCLK, negedge HRESETn)
+  always @(posedge HCLK)
     if      (!HRESETn   ) granted_master_idx <= 'h0;
     else if ( slv_HREADY)
       if (can_switch_master) granted_master_idx <= pending_master_idx;
@@ -344,4 +346,4 @@ module ahb3lite_interconnect_slave_port #(
   assign mstHRESP     =  slv_HRESP;
 endmodule
 
-
+/* verilator lint_on WIDTH */
diff --git a/rtl/verilog/ahb3lite_interconnect_slave_priority.sv b/rtl/verilog/ahb3lite_interconnect_slave_priority.sv
index 8b94881..916781f 100644
--- a/rtl/verilog/ahb3lite_interconnect_slave_priority.sv
+++ b/rtl/verilog/ahb3lite_interconnect_slave_priority.sv
@@ -53,7 +53,7 @@
 //  HI
 //  LO
 // ------------------------------------------------------------------
-// REUSE ISSUES 
+// REUSE ISSUES
 //   Reset Strategy      : none
 //   Clock Domains       : none
 //   Critical Timing     :
@@ -62,7 +62,7 @@
 //   Scan Methodology    : na
 //   Instantiations      : Itself (recursive)
 //   Synthesizable (y/n) : Yes
-//   Other               :                                         
+//   Other               :
 // -FHDR-------------------------------------------------------------
 
 module ahb3lite_interconnect_slave_priority #(
@@ -71,7 +71,7 @@ module ahb3lite_interconnect_slave_priority #(
   parameter LO         = 0,
 
   //really a localparam
-  parameter PRIORITY_BITS = $clog2(MASTERS)
+  parameter PRIORITY_BITS = $clog2(MASTERS+1)
 )
 (
   input  [MASTERS      -1:0]                    HSEL,
diff --git a/sw/ahb3lite_intercon.py b/sw/ahb3lite_intercon.py
new file mode 100644
index 0000000..dc1c4fd
--- /dev/null
+++ b/sw/ahb3lite_intercon.py
@@ -0,0 +1,319 @@
+#!/usr/bin/env python
+import sys
+from collections import OrderedDict, defaultdict
+import yaml
+import math
+
+from verilogwriter import Signal, Wire, Instance, ModulePort, VerilogWriter, LocalParam, Assign
+
+AHB3_MASTER_PORTS = [
+  Signal('HSEL'),
+  Signal('HADDR', 32),
+  Signal('HWDATA', 32),
+  Signal('HWRITE'),
+  Signal('HSIZE', 3),
+  Signal('HBURST', 3),
+  Signal('HPROT', 4),
+  Signal('HTRANS', 2),
+  Signal('HMASTLOCK'),
+  #Signal('HREADYOUT'),
+]
+
+AHB3_SLAVE_PORTS  = [
+  Signal('HRDATA', 32),
+  Signal('HRESP'),
+  #Signal('HREADY'),
+]
+
+AHB3_DATA_WIDTH = defaultdict(float, { 'dat': 1.0 })
+
+class Error(Exception):
+  """Base error for ahb3_intercon_gen"""
+
+class UnknownPropertyError(Error):
+  """An unknown property was encounterned while parsing the config file."""
+
+def parse_number(s):
+    if type(s) == int:
+        return s
+    if s.startswith('0x'):
+        return int(s, 16)
+    else:
+        return int(s)
+
+class Master:
+    def __init__(self, name, index, d=None):
+        self.name = name
+        self.index = index
+        self.datawidth = 32
+        self.slaves = []
+        self.priority = 0
+        if d:
+            self.load_dict(d)
+
+    def load_dict(self, d):
+      for key, value in d.items():
+        if key == 'priority':
+          self.priority = int (value)
+        elif key == 'slaves':
+          self.slaves = value
+        else:
+          raise UnknownPropertyError(
+            "Unknown property '%s' in master section '%s'" % (
+              key, self.name))
+
+class Slave:
+    def __init__(self, name, index, d=None):
+        self.name = name
+        self.index = index
+        self.masters = []
+        self.datawidth = 32
+        self.offset = 0
+        self.size = 0
+        self.mask = 0
+        if d:
+            self.load_dict(d)
+
+    def load_dict(self, d):
+        for key, value in d.items():
+            if key == 'datawidth':
+                self.datawidth = parse_number(value)
+            elif key == 'offset':
+                self.offset = parse_number(value)
+            elif key == 'size':
+                self.size = parse_number(value)
+                self.mask = ~(self.size-1) & 0xffffffff
+            elif key == 'idx':
+                pass
+            else:
+                raise UnknownPropertyError(
+                    "Unknown property '%s' in slave section '%s'" % (
+                    key, self.name))
+
+class Parameter:
+    def __init__(self, name, value):
+        self.name  = name
+        self.value = value
+
+class Port:
+    def __init__(self, name, value):
+        self.name = name
+        self.value = value
+
+def xsort(a):
+  print (a[0])
+  print (a[1])
+  print (type (a))
+
+class AHB3Intercon:
+    def __init__(self, name, config_file):
+        self.verilog_writer = VerilogWriter(name)
+        self.template_writer = VerilogWriter(name);
+        self.name = name
+        d = OrderedDict()
+        self.slaves = OrderedDict()
+        self.masters = OrderedDict()
+        import yaml
+
+        def ordered_load(stream, Loader=yaml.Loader, object_pairs_hook=OrderedDict):
+            class OrderedLoader(Loader):
+                pass
+            def construct_mapping(loader, node):
+                loader.flatten_mapping(node)
+                return object_pairs_hook(loader.construct_pairs(node))
+            OrderedLoader.add_constructor(
+                yaml.resolver.BaseResolver.DEFAULT_MAPPING_TAG,
+                construct_mapping)
+            return yaml.load(stream, OrderedLoader)
+        data = ordered_load(open(config_file))
+
+        config     = data['parameters']
+        files_root = data['files_root']
+        self.vlnv       = data['vlnv']
+
+        index = 0
+        for k,v in config['masters'].items():
+            print("Found master " + k)
+            self.masters[k] = Master(k,index,v)
+            index = index + 1
+        index = 0
+        # Sort by idx param
+        for k,v in config['slaves'].items():
+          v.setdefault ('idx', 1)
+        sslaves = sorted (config['slaves'].items(), key=lambda x: x[1]['idx'])
+        for k,v in sslaves:
+            print("Found slave " + k)
+            self.slaves[k] = Slave(k,index,v)
+            index = index + 1
+
+        #Create master/slave connections
+        for master, slaves in d.items():
+            for slave in slaves:
+                self.masters[master].slaves += [self.slaves[slave]]
+                self.slaves[slave].masters += [self.masters[master]]
+
+        self.output_file = config.get('output_file', 'ahb3lite_intercon.sv')
+
+    def _dump(self):
+        print("*Masters*")
+        for master in self.masters.values():
+            print(master.name)
+            for slave in master.slaves:
+                print(' ' + slave.name)
+
+        print("*Slaves*")
+        for slave in self.slaves.values():
+            print(slave.name)
+            for master in slave.masters:
+                print(' ' + master.name)
+
+    def write(self):
+        file = self.output_file
+
+        # Template port/parameters
+        template_ports = [Port('clk', 'CLK'),
+                          Port('reset_n', 'RESETn')]
+        template_parameters = []
+
+
+        # Gen top level ports
+        self.verilog_writer.add(ModulePort('clk', 'input'))
+        self.verilog_writer.add(ModulePort('reset_n', 'input'))
+
+        # Declare global wires to pass to instantiation
+        self.verilog_writer.add (LocalParam ('MASTERS', len (self.masters)))
+        self.verilog_writer.add (LocalParam ('SLAVES', len (self.slaves)))
+        mclog2 = max([math.ceil(math.log2(len (self.masters))), 2])
+        self.verilog_writer.add (Wire ('mst_priority', mclog2, append=' [MASTERS]'))
+        self.verilog_writer.add (Wire ('slv_addr_base', 32, append=' [SLAVES]'))
+        self.verilog_writer.add (Wire ('slv_addr_mask', 32, append=' [SLAVES]'))
+        for p in AHB3_MASTER_PORTS:
+          self.verilog_writer.add (Wire ('mst_{0}'.format (p.name), p.width, append=' [MASTERS]'))
+          self.verilog_writer.add (Wire ('slv_{0}'.format (p.name), p.width, append=' [SLAVES]'))
+        for p in AHB3_SLAVE_PORTS:
+          self.verilog_writer.add (Wire ('mst_{0}'.format (p.name), p.width, append=' [MASTERS]'))
+          self.verilog_writer.add (Wire ('slv_{0}'.format (p.name), p.width, append=' [SLAVES]'))
+        # Add HREADY/HREADYOUT
+        self.verilog_writer.add (Wire ('mst_HREADY', append=' [MASTERS]'))
+        self.verilog_writer.add (Wire ('slv_HREADY', append=' [SLAVES]'))
+        self.verilog_writer.add (Wire ('mst_HREADYOUT', append=' [MASTERS]'))
+        self.verilog_writer.add (Wire ('slv_HREADYOUT', append=' [SLAVES]'))
+
+        # Generate master wires
+        for key, value in self.masters.items():
+          for p in AHB3_MASTER_PORTS:
+            self.template_writer.add (Wire ('{0}_{1}'.format (key, p.name), p.width))
+            self.verilog_writer.add(ModulePort('{0}_{1}'.format (key, p.name), 'input', p.width))
+            template_ports += [Port ('{0}_{1}'.format (key, p.name), '{0}_{1}'.format (key, p.name))]
+          for p in AHB3_SLAVE_PORTS:
+            self.template_writer.add (Wire ('{0}_{1}'.format (key, p.name), p.width))
+            self.verilog_writer.add(ModulePort('{0}_{1}'.format (key, p.name), 'output', p.width))
+            template_ports += [Port ('{0}_{1}'.format (key, p.name), '{0}_{1}'.format (key, p.name))]
+          # Add HREADY input port
+          self.verilog_writer.add(ModulePort('{0}_{1}'.format (key, 'HREADY'), 'output'))
+          self.template_writer.add (Wire ('{0}_{1}'.format (key, 'HREADY')))
+          template_ports += [Port ('{0}_{1}'.format (key, 'HREADY'), '{0}_{1}'.format (key, 'HREADY'))]
+
+        # Generate slave wires
+        for key, value in self.slaves.items():
+          for p in AHB3_MASTER_PORTS:
+            self.template_writer.add (Wire ('{0}_{1}'.format (key, p.name), p.width))
+            self.verilog_writer.add(ModulePort('{0}_{1}'.format (key, p.name), 'output', p.width))
+            template_ports += [Port ('{0}_{1}'.format (key, p.name), '{0}_{1}'.format (key, p.name))]
+          for p in AHB3_SLAVE_PORTS:
+            self.template_writer.add (Wire ('{0}_{1}'.format (key, p.name), p.width))
+            self.verilog_writer.add(ModulePort('{0}_{1}'.format (key, p.name), 'input', p.width))
+            template_ports += [Port ('{0}_{1}'.format (key, p.name), '{0}_{1}'.format (key, p.name))]
+          # Add HREADY/HREADYOUT  ports
+          self.template_writer.add (Wire ('{0}_{1}'.format (key, 'HREADY')))
+          self.verilog_writer.add(ModulePort('{0}_{1}'.format (key, 'HREADY'), 'output'))
+          self.template_writer.add (Wire ('{0}_{1}'.format (key, 'HREADYOUT')))
+          self.verilog_writer.add(ModulePort('{0}_{1}'.format (key, 'HREADYOUT'), 'input'))
+          template_ports += [Port ('{0}_{1}'.format (key, 'HREADY'), '{0}_{1}'.format (key, 'HREADY'))]
+          template_ports += [Port ('{0}_{1}'.format (key, 'HREADYOUT'), '{0}_{1}'.format (key, 'HREADYOUT'))]
+
+        # Generate master assignments
+        for key, val in self.masters.items():
+          self.verilog_writer.add (Assign ('mst_{0} [{1}]'.format ('priority', val.index), val.priority))
+          for p in AHB3_MASTER_PORTS:
+            self.verilog_writer.add (Assign ('mst_{0} [{1}]'.format (p.name, val.index), '{0}_{1}'.format (key, p.name)))
+          for p in AHB3_SLAVE_PORTS:
+            self.verilog_writer.add (Assign ('{0}_{1}'.format (key, p.name), 'mst_{0} [{1}]'.format (p.name, val.index)))
+          # Add HREADY assignments
+          self.verilog_writer.add (Assign ('mst_{0} [{1}]'.format ('HREADY', val.index), 'mst_{0} [{1}]'.format ('HREADYOUT', val.index)))
+          self.verilog_writer.add (Assign ('{0}_{1}'.format (key, 'HREADY'), 'mst_{0} [{1}]'.format ('HREADYOUT', val.index)))
+
+        # Generate slave assignments
+        for key, val in self.slaves.items():
+          self.verilog_writer.add (Assign ('slv_addr_base [{0}]'.format (val.index), val.offset, width=32))
+          self.verilog_writer.add (Assign ('slv_addr_mask [{0}]'.format (val.index), ~(val.size - 1), width=32))
+          for p in AHB3_MASTER_PORTS:
+            self.verilog_writer.add (Assign ('{0}_{1}'.format (key, p.name), 'slv_{0} [{1}]'.format (p.name, val.index)))
+          for p in AHB3_SLAVE_PORTS:
+            self.verilog_writer.add (Assign ('slv_{0} [{1}]'.format (p.name, val.index), '{0}_{1}'.format (key, p.name)))
+          # Add HREADY assignments
+          self.verilog_writer.add (Assign ('slv_{0} [{1}]'.format ('HREADY', val.index), '{0}_{1}'.format (key, 'HREADYOUT')))
+          self.verilog_writer.add (Assign ('{0}_{1}'.format (key, 'HREADY'), 'slv_{0} [{1}]'.format ('HREADYOUT', val.index)))
+
+        # Instantiate interconnect
+        inter_param = [Parameter ('MASTERS', len (self.masters)),
+                       Parameter ('SLAVES', len (self.slaves)),
+                       Parameter ('HADDR_SIZE', 32),
+                       Parameter ('HDATA_SIZE', 32),
+                       ]
+        inter_ports = [Port ('HCLK', 'clk'),
+                       Port ('HRESETn', 'reset_n'),
+                       Port ('mst_priority', 'mst_priority'),
+                       Port ('slv_addr_base', 'slv_addr_base'),
+                       Port ('slv_addr_mask', 'slv_addr_mask'),
+                       Port ('mst_HREADY', 'mst_HREADY'),
+                       Port ('slv_HREADY', 'slv_HREADY'),
+                       Port ('mst_HREADYOUT', 'mst_HREADYOUT'),
+                       Port ('slv_HREADYOUT', 'slv_HREADYOUT'),
+        ]
+        inter_ports += [Port ('mst_'+p.name, 'mst_'+p.name) for p in AHB3_MASTER_PORTS]
+        inter_ports += [Port ('slv_'+p.name, 'slv_'+p.name) for p in AHB3_MASTER_PORTS]
+        inter_ports += [Port ('mst_'+p.name, 'mst_'+p.name) for p in AHB3_SLAVE_PORTS]
+        inter_ports += [Port ('slv_'+p.name, 'slv_'+p.name) for p in AHB3_SLAVE_PORTS]
+        self.verilog_writer.add (Instance ('ahb3lite_interconnect', 'ahb3lite_intercon0', inter_param, inter_ports))
+
+        # Create template
+        self.template_writer.add(Instance(self.name, self.name+'0',
+                                          template_parameters, template_ports))
+
+        self.verilog_writer.write(file)
+        self.template_writer.write(file[:-2]+'vh')
+
+        core_file = self.vlnv.split(':')[2]+'.core'
+        vlnv = self.vlnv
+        with open(core_file, 'w') as f:
+            f.write('CAPI=2:\n')
+            files = [{file     : {'file_type' : 'verilogSource'}},
+                     {file[:-2]+'vh' : {'is_include_file' : True,
+                                  'file_type' : 'verilogSource'}}
+            ]
+            coredata = {'name' : vlnv,
+                        'targets' : {'default' : {}},
+            }
+
+            coredata['filesets'] = {'rtl' : {'files' : files}}
+            coredata['targets']['default']['filesets'] = ['rtl']
+
+            f.write(yaml.dump(coredata))
+
+if __name__ == "__main__":
+    #if len(sys.argv) < 3 or len(sys.argv) > 4:
+        #print("ahb3_intercon_gen <config_file> <out_file> [module_name]")
+        #exit(0)
+    name = "ahb3lite_intercon"
+    if len(sys.argv) == 4:
+      name = sys.argv[3]
+    try:
+      g = AHB3Intercon(name, sys.argv[1])
+      if len(sys.argv) > 2:
+          g.output_file = sys.argv[2]
+      print("="*80)
+      g.write()
+    except Error as e:
+      print("Error: %s" % e)
+      exit(1)
diff --git a/sw/verilogwriter.py b/sw/verilogwriter.py
new file mode 100644
index 0000000..d784f5c
--- /dev/null
+++ b/sw/verilogwriter.py
@@ -0,0 +1,130 @@
+class Signal(object):
+    def __init__(self, name, width=0, low=0, asc=False, append=''):
+        self.name = name
+        self.width=width
+        self.low = low
+        self.asc = asc
+        self.append = append
+
+    def range(self):
+        if self.width > 0:
+            l = self.width+self.low-1
+            r = self.low
+            if self.asc:
+                return '['+str(r)+':'+str(l)+']'
+            else:
+                return '['+str(l)+':'+str(r)+']'
+        return ''
+
+class Wire(Signal):
+    def write(self, width):
+        return 'wire{range} {name}{append};\n'.format(range=self.range().rjust(width), name=self.name, append=self.append)
+
+class ModulePort(Signal):
+    def __init__(self, name, dir, width=0, low=0, asc=False):
+        super(ModulePort, self).__init__(name, width, low, asc)
+        self.dir = dir
+
+    def write(self, range_width=0):
+        return '{dir} {range} {name}'.format(dir=self.dir.ljust(6), range=self.range().rjust(range_width), name=self.name)
+
+class LocalParam:
+    def __init__(self, name, val):
+        self.name = name
+        self.val = val
+    def write(self):
+        return 'localparam {name} = {val};\n'.format (name=self.name, val=self.val)
+
+class Assign:
+    def __init__(self, name, val, width=0):
+        self.name = name
+        self.val = val
+        self.width = width
+    def convert(self):
+        if self.width:
+            return '{0}\'h{1}'.format (self.width, hex((self.val + (1 << self.width)) % (1 << self.width))[2:])
+        else:
+            return self.val
+    def write(self):
+        return 'assign {name} = {val};\n'.format (name=self.name, val=self.convert())
+
+class Instance:
+    def __init__(self, module, name, parameters, ports):
+        self.module = module
+        self.name = name
+        self.parameters = parameters
+        self.ports = ports
+
+    def write(self):
+        s = self.module
+        if self.parameters:
+            max_len = max([len(p.name) for p in self.parameters])
+            s += '\n  #('
+            s += ',\n    '.join(['.' + p.name.ljust(max_len) +' (' + str(p.value) + ')' for p in self.parameters])
+            s += ')\n'
+        s += ' ' + self.name
+
+        if self.ports:
+            s += '\n   ('
+            max_len = max([len(p.name) for p in self.ports])
+            s += ',\n    '.join(['.' + p.name.ljust(max_len) +' (' + str(p.value) + ')' for p in self.ports])
+            s += ')'
+        s += ';\n'
+        return s
+
+class VerilogWriter:
+    def __init__(self, name):
+        self.name = name
+        self.instances = []
+        self.ports = []
+        self.wires = []
+        self.lp = []
+        self.assign = []
+
+    def add(self, obj):
+        if isinstance(obj, Instance):
+            self.instances += [obj]
+        elif isinstance(obj, ModulePort):
+            self.ports += [obj]
+        elif isinstance(obj, Wire):
+            self.wires += [obj]
+        elif isinstance(obj, LocalParam):
+            self.lp += [obj]
+        elif isinstance(obj, Assign):
+            self.assign += [obj]
+        else:
+            raise Exception("Invalid type!" + str(obj))
+
+    def write(self, file=None):
+        s = ("// THIS FILE IS AUTOGENERATED BY ahb3lite_intercon_gen\n"
+             "// ANY MANUAL CHANGES WILL BE LOST\n")
+        if self.ports:
+            s += "module {name}\n".format(name=self.name)
+            max_len = max([len(p.range()) for p in self.ports])
+            s += '   ('
+            s += ',\n    '.join([p.write(max_len) for p in self.ports])
+            s += ')'
+            s += ';\n\n'
+        if self.lp:
+            for lp in self.lp:
+                s += lp.write ()
+            s += '\n'
+        if self.wires:
+            max_len = max([len(w.range()) for w in self.wires])
+            for w in self.wires:
+                s += w.write(max_len + 1)
+            s +='\n'
+        if self.assign:
+            for a in self.assign:
+                s += a.write ()
+            s += '\n'
+        for i in self.instances:
+            s += i.write()
+            s += '\n'
+        if self.ports:
+            s += 'endmodule\n'
+        if file is None:
+            return s
+        else:
+            f = open(file,'w')
+            f.write(s)
-- 
2.20.1

